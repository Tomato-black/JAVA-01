 1、随着堆内存的增大，GC的STW时间增长，但GC的频率会降低
 
 2、不同GC在相同内存环境下，产生的效果差异很大
 
**Serial:**  
启用参数：-XX:+UseSerialGC  
优点：单线程精简的垃圾收集器，小内存回收效率很高。  
缺点：STW  
由于客户端应用一般不会占用很大内存，且不会频繁的创建对象，所以适合使用Serial+Serial Old  
**Parallel:**  
启用参数：-XX:+UseParallelGC  
jdk8及以前jvm默认的垃圾收集器  
优点：新生代和老年代使用并行收集非常高效。所以它也是吞吐量优先的GC  
缺点：STW  
由于ParallelGC使用并行收集非常高效，但缺点是STW时间较长，所以它适合用在一些对延时不是很敏感的系统中，例如数据跑批  
**CMS+ParNew**  
启用参数：-XX:+UseConcMarkSweepGC -XX:+UseParNewGC
ParNew 是Serial的多线程版本，通常和CMS配合使用，jdk9中已经不使用了  
CMS 并发标记清除  
优点：CMS被设计为尽量减少STW停顿时间的垃圾收集器  
缺点：由于使用了标记-清除算法，存在碎片化问题，且CMS只有在Full GC才会触发内存整理，在长时间运行的情况下会发生full GC，导致恶劣停顿。会占用更多的CPU资源，和用户争抢线程  
在一些对延时要求高的Web系统中使用（一般是内存小于8G的，大于8G 则G1是更好的选择，因为CMS原本就G1的一个过渡产品）    
**G1**  
启用参数：-XX:+UseG1GC  
兼顾了吞吐量和停顿时间的GC实现，是Oracle JDK 9后默认的GC可以直观的设值停顿时间，相对于CMS GC ，G1未必能做到CMS最好情况下的延时停顿，但比最差情况要好得多    
G1 仍存在年代的概念，使用了Region棋盘算法，实际上是标记-整理（Mark-Compact）算法，可以避免内存碎片，尤其是堆非常大的时候，G1优势更明显。  
G1 吞吐量和停顿表现都非常不错  

总结一下就是：没有最好的GC，只有最合适的GC,我们需要根据具体的业务场景，通过大量的调试、测试，最终得到一个可以对我们业务提升最大的垃圾回收器组合  

最后我们可以通过计算 对象分配速率、对象提升速率，来判断我们怎么内存调优  
对象分配速率越高，则Young GC 频率越高  
对象提升速率越高，则Old GC 频率越高  
当对象提升速率越来越趋近于对象分配速率越高时，我们需要注意是否存在对象的过早提升现象  
